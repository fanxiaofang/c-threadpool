本项目基于github的[Threadpool](https://github.com/mbrossard/threadpool)，适合学习<br>
github[这个线程池项目](https://github.com/Pithikos/C-Thread-Pool#) 也可以学习
## 一、总体结构与设计
基于经典的 线程池+环形任务队列+互斥锁+条件变量，核心特性：
- 任务队列
    固定大小数组实现环形缓冲区，head tail索引控制任务添加和消费
- 线程同步
    - 互斥锁lock保护共享数据
    - 任务队列非空通知条件变量notify，工作线程等待新任务
    - 任务队列非满通知条件变量queue_not_full, 添加任务时满任务队列阻塞等待空位
    - 线程暂停恢复通知条件变量notufy_pause,实现暂停时工作线程阻塞不再取新任务(不影响已经取了任务正在执行的工作线程) 和恢复时唤醒工作线程继续工作
- 线程生命周期管理
    - started计数已经启动的线程数
    - shutdown标志控制线程池关闭（立即关闭or优雅关闭）
- 线程池状态管理
    - state为线程池运行或暂停状态，控制工作线程是否取任务执行
    - paused_threads统计当前处于暂停的线程数

1. 线程池结构体`threadpool_t`
```c
struct threadpool_t {
  pthread_mutex_t lock;           // 互斥锁，保护共享数据结构
  pthread_cond_t notify;          // 条件变量，任务队列空时，等待任务队列非空
  pthread_cond_t queue_not_full;  // 条件变量，任务队列满时 等待队列非满
 pthread_cond_t notify_pause;     // 条件变量，线程池被暂停时，等待恢复
  pthread_t *threads;             // 线程数组
  threadpool_task_t *queue;       // 任务队列（环形缓冲区）
  int thread_count;               // 线程数
  int queue_size;                 // 任务队列大小
  int head;                      // 队头索引（下一个待执行任务）
  int tail;                      // 队尾索引（下一个待添加任务位置）
  int count;                     // 当前任务数量
  int started;                   // 当前存活线程数
  threadpool_shutdown_t shutdown;// 线程池关闭标志（0：运行，1或2：关闭）
  threadpool_state_t state;      // 线程池状态 （0：运行中，1：暂停中
  int paused_threads;           // 暂停的线程数
};

```
- 互斥锁`lock`保护临界资源,并配合条件变量的使用
- 条件变量`notify`
    - 线程工作函数在任务队列为空时阻塞等待在该条件变量上 `pthread_cond_wait`
    - 添加任务函数中通知有新任务`pthread_cond_signal`
    - 销毁线程池时，唤醒所有线程(等待任务的线程)`pthread_cond_broadcast`
- 条件变量`queue_not_full`
    - 添加任务时，如果当前任务队列已满，之前的做法是直接返回错误，需要用户自行判断，现在修改为任务队列满时，添加任务的线程会阻塞到该条件变量上，等待工作线程取走任务，空出位置之后通知该条件变量，然后继续添加任务到任务队列
    - 销毁线程池时，需要广播唤醒阻塞在该条件变量上的线程
- 条件变量`notify_pause`
    - 线程工作函数通过`while`循环判断当前线程池的状态如果是暂停且非关闭的状态，则阻塞等待在该条件变量上，直到收到恢复的通知，才会继续往下执行，从任务队列中取走任务
    - 销毁线程池时，需广播唤醒阻塞在该条件变量上的工作线程
- 环形缓冲区实现的**任务队列**（数据结构是数组），`head`和`tail`数组索引循环移动，线程取走任务时`head`向后移动，向任务队列中添加任务时，`tail`向后移动，`count`同步任务队列中的任务个数
- 线程池状态由`shutdown`标志控制，支持两种关闭线程池方式
    - `immediate_shutdown` ：立即关闭，强制终止线程
    - `graceful_shutdown`: 优雅关闭线程池，等待任务完成后退出
- `started` 跟踪当前存活的线程数，在销毁线程池用来判断是否可以安全释放资源
2. 任务结构体`threadpool_task_t`
```c
typedef struct {
    void (*function)(void *);
    void *argument;
} threadpool_task_t;

```
每个任务结构体封装了函数指针，以及传递给该函数的参数`argument`
  
## 二、核心功能分析
1. 线程池创建 `threadpool_create`
- 参数检查，限制最大线程数和队列大小
- 分配线程池结构体内存
    - 初始化线程池结构体成员
    - 分配线程ID数组和任务队列数组内存
    - 初始化互斥锁`lock`和条件变量`notify`、`queue_not_full`,`notify_pause`
- 逐个创建线程`pthread_create`，指定线程入口函数是`threadpool_thread`，将线程池结构体作为参数传递给线程函数
2. 添加任务 `threadpool_add`
- 加互斥锁`lock`
- `while`循环判断当前任务队列如果已满，且不是关闭状态，则阻塞等待在`queue_not_full`条件变量，而不是直接返回错误让生产者处理，这样避免了任务的可能丢失
- 等工作线程从任务队列中取走任务时，通过`pthread_cond_signal`通知等待在该条件变量的线程之后，继续往下执行添加任务的流程
- 计算存储新任务的索引，`tail`后移一个位置,`next=(tail+1)%queue_size`
- 检查任务队列是否满，满则返回错误码 让调用方处理，todo:此处另一种处理方式是阻塞等待
- 将任务放入`queue[tail]`
    - 赋值任务结构体（函数指针 参数）
    - 更新任务队列的`tail`和任务个数`count`
- 通知等待在条件变量`notify`的线程有了新任务，`pthread_cond_signal`不使用`broacast`是防止**惊群效应**
- 释放互斥锁`lock`
3. 线程工作函数 `threadpool_thread`
每个工作线程**循环**执行：
- 加互斥锁`lock`
- `while`循环判断：当任务队列为空且线程池未关闭时，在条件变量`notify`等待(`pthread_cond_wait`)
- `while`循环判断，当前线程池如果处于暂停且非关闭状态时，在条件变量`notify_pause`等待
- 检查线程池的关闭条件(立即关闭或者无优雅关闭且无任务)，减少线程池的存活线程数`started--`,释放互斥锁`lock`,退出线程`pthread_exit`
- 否则 取出任务队列的头部任务,并更新`head`和任务队列任务数`count`
- 释放互斥锁 `lock`
- 执行任务函数，（任务函数中需用户自行解决数据竞争问题）
- 继续循环
4. 线程池销毁`pthreadpool_destroy`
- 加互斥锁`lock`检查线程池状态，标记关闭方式
- `pthread_cond_broadcast`唤醒所有等待条件变量的线程
- 释放互斥锁
- `pthread_join`等待所有线程退出
- 释放线程池资源
5. 释放线程池资源 `pthreadpool_free`
- 确保所有线程已经退出（`started == 0`）
- 释放线程池的线程ID数组、任务队列数组
- 销毁互斥锁`lock`、条件变量`notify`
- 释放线程池结构体资源
6. 线程暂停和恢复
- 线程池暂停恢复的应用场景：
    - 资源系统紧张或者维护时刻临时控制并发量
    - 批量任务调度控制，
    - 调试测试场景，方便观察线程状态或同步调试
    - 系统被动等待外部条件
- 调用方式
线程池的使用方通过调用`threadpool_pause thread_resume`两个接口控制线程池的暂停和恢复
- 实现
暂停时，将线程池的状态设置为`pool_paused`,所有工作线程在取任务之前检测到暂停且非关闭状态时，阻塞在`notify_pause`条件变量
恢复时，将线程池的状态设置为`pool_running`,并调用`pthread_cond_broadcast`广播通知阻塞在`notify_pause`条件变量的工作线程
7. 允许任务队列满时进行阻塞等待，避免满队列时任务丢失
- 线程池结构体中新增条件变量`queue_not_full`,用于通知任务队列非满状态
- 在`threadpool_add`添加任务函数中，加互斥锁后，若发现队列满，调用`pthread_cond_wait`阻塞
- 线程池工作线程执行任务后，取出任务，给任务队列空出位置，此时唤醒`queue_not_full`条件变量，通知可能阻塞的生产者（添加任务者）可以继续添加任务
- 关闭线程池时需要唤醒所有阻塞`threadpool_add`添加任务的线程，避免死锁


## 三、同步机制总结
- 互斥锁`lock`:保护所有共享资源(共享变量)，包括任务队列、任务队列索引和任务计数、活动线程数(`started`)、线程池关闭状态(`shutdown`)，保证线程之间对这些共享资源能够**互斥访问**
- 条件变量`notify`:
    - 任务队列为空且线程池非关闭状态时，线程阻塞等待条件变量通知
    - 添加任务后调用`pthread_cond_signal`唤醒一个等待线程，这里用`*_signal`避免唤醒所偶线程造成**惊群效应**
    - 关闭线程池时调用`pthread_cond_broadcast`通知所有等待线程 让它们退出
- 条件变量`queue_not_full`
- 条件变量`notify_pause`
- 先获取互斥锁+`while`循环判断等待条件变量，防止虚假唤醒（指`threadpool_thread`线程函数中，互斥锁+条件变量的经典消费者生产者模型使用方式）
- 活动线程计数`started`
    - 记录存活的线程数
    - 线程退出时减1，销毁资源时确保所有线程退出
- todo
条件变量`notify`通知工作线程任务队列非空可以取任务执行，条件变量`queue_not_full`通知生产者任务队列非满，可以添加任务，这两个条件变量或可以合并为一个条件变量
三个条件变量的风险点
- 死锁：确保调用pthread_cond_wait时持有锁（满足）
- 虚假唤醒：确保适用`while`循环判断等待条件（满足）
- 错误通知：严格区分条件变量用途，准确调用通知函数（三个条件变量时满足）
- 竟态条件 修改状态和调用通知操作由互斥锁保护（满足）
建议：
如果生产者和消费者线程数都比较少，唤醒的线程数不多 可以考虑将`notify` `queue_not_full`合并为一个条件变量使用

## 四、设计优缺点以及改进

| 设计点 | 优势 | 可能改进 |
|:-----:|:-----:|:-----:|
|固定大小任务队列环形缓冲区|内存连续<br>访问效率高<br>无链表指针开销|无动态扩容，队列满时无法入队|
|同步机制|互斥锁+条件变量，标准的线程同步，简洁高效|略|
|线程池关闭方案|支持立即关闭和优雅关闭，使用shutdown+条件变量的广播通知实现|立即关闭时线程可能正在执行任务，强制关闭不够优雅|
|错误处理|任务添加返回详细错误码，线程创建失败时资源释放完善|**任务队列满时失败，缺少阻塞等待或者任务覆盖策略**|
|线程退出计数|`started`活动线程计数保证资源安全释放|计数操作依赖互斥锁保护，未使用原子操作|

## 五、总结
该线程池适用场景：
- 任务量固定或可控，追求稳定、高性能和易维护的生产环境
该线程池实现：
- 简洁且功能完整，适合中小规模的多线程任务管理
- 采用环形缓冲区作为任务队列（数组），避免链表带来的内存分配和指针开销
- 利用互斥锁+条件变量实现线程间同步，保障线程安全
- 支持两种线程池关闭方式，兼顾灵活性和安全性
- 代码易读，结构清晰，易于维护和扩展

如何进一步完善:<br>
1. 动态调整线程数量
2. 动态调整任务队列大小
    需要考虑是选择可动态扩容的数组缓冲区队列，还是链表队列
    选择因素	                推荐方案	         备注
    任务入队频率高且不规则	     链表队列	适合任务量爆发型，节点大小不确定，避免扩容阻塞
    系统对性能/延迟要求高	     可扩容数组环形队列	缓存友好，访问效率高；适合高性能场景
    任务数量范围可预估且波动较小  可扩容数组环形队列	初始容量合适，扩容次数少，避免频繁内存分配
    任务入队和出队操作简单	     两者均适用	但链表灵活性更好
    系统内存较紧张	            链表队列	避免数组扩容带来的内存浪费
    代码实现复杂度和可维护性需求高	链表队列	逻辑更直观，便于维护
3. 使用原子操作优化计数器，减少锁的粒度
4. 增加发送信号暂停线程（通过SIGUSER1自定义信号）


## 一些线程池的常见的设计问题
### 总体架构和设计思路
- 任务队列的实现(数据结构选择)
    - 本项目中：固定大小的环形缓冲区数组，实现循环队列（head、tail）
    - 其他可能：单向或者双向链表
- 任务通知机制
    - 本项目中：POSIX互斥锁和条件变量
- 线程等待策略
    - 本项目中：条件变量等待任务队列非空
    - 其他可能：任务队列中定义一个二元信号量，等待二元信号量阻塞等待任务(类似`sem_wait`)
- 任务添加行为
    - 本项目中：任务入队后通过条件变量`pthread_cond_signal`通知等待线程
    - 其他可能：任务入队后通过二元信号量通知等待线程，类似`sem_post`
- 线程池关闭模式
    - 本项目：通过`shutdown`标志变量控制线程退出
    - 其他可能：发送信号暂停线程，支持暂停 恢复
- 线程管理
    - 本项目：线程数组管理，循环等待任务，线程退出时减少线程存活计数
    - 其他可能：线程结构封装，线程创建后循环wait任务，退出时更新状态（分离线程）
- 任务执行方式
    - 本项目：取环形队列头任务执行，执行完释放锁，继续等待
- 同步复杂度
    - 本项目：互斥锁+条件变量

## 任务队列结构与性能
1. 任务队列类型
2. 内存管理
    - 本项目：预分配固定大小的任务数组
3. 任务入队
    - 本项目：直接写数组tail索引处，更新索引
4. 任务出队
    - 本项目：读取数组head索引处任务，更新索引
5. 队列满处理
    - 本项目：固定大小，有队满判断
7. 队列是否支持扩容

## 线程同步与阻塞机制
1. 等待任务方式
2. 任务唤醒策略
3. 队列满时任务添加行为
4. 线程暂停机制
5. 线程退出条件判断
6. 线程状态计数器
7. 任务执行时锁状态
## 线程池关闭与销毁
1. 关闭方式
2. 线程退出顺序
3. 资源释放
4. 清理同步机制
